<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RSR vs Quaternions — Visual + 10M Benchmark</title>
  <style>
    html, body { margin:0; height:100%; background:#000; color:#fff; font-family:monospace; }
    #topbar {
      position:fixed; top:10px; left:10px; right:10px; z-index:10;
      display:flex; gap:12px; align-items:center; flex-wrap:wrap;
      background:rgba(0,0,0,.6); padding:8px 12px; border-radius:8px;
    }
    #stats { display:flex; gap:18px; align-items:center; flex-wrap:wrap; }
    .mono { font-variant-numeric: tabular-nums; }
    button { padding:6px 10px; border-radius:6px; border:1px solid #444; background:#111; color:#fff; cursor:pointer; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    input, select {
      background:#111; color:#fff; border:1px solid #444; border-radius:6px; padding:6px 8px;
    }
    input[type="number"] { width:110px; }
    pre {
      position:fixed; left:10px; right:10px; bottom:10px; max-height:40vh; overflow:auto;
      background:rgba(0,0,0,.6); padding:8px 12px; border-radius:8px; font-size:12px; line-height:1.35;
    }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
  <div id="topbar" class="mono">
    <div>phase: <span id="ph">0</span></div>
    <div id="stats">
      Z max:<span id="zmax">—</span> rms:<span id="zrms">—</span>
      X max:<span id="xmax">—</span> rms:<span id="xrms">—</span>
      Y max:<span id="ymax">—</span> rms:<span id="yrms">—</span>
      ZXY max:<span id="cmax">—</span> rms:<span id="crms">—</span>
    </div>
    <div style="flex:1"></div>
    <label>Ops:
      <input id="ops" type="number" value="10000000" min="1000" step="1000"/>
    </label>
    <label>Mode:
      <select id="mode">
        <option value="api" selected>API (canonicalize)</option>
        <option value="kernel">Kernel (no canonicalize)</option>
      </select>
    </label>
    <button id="runRnd">Run Bench (Random)</button>
    <button id="runEdge">Run Bench (Edge Cases)</button>
  </div>

  <canvas id="cv"></canvas>
  <pre id="log" class="mono"></pre>

  <!-- Order matters -->
  <script src="customtrig.js"></script>   <!-- provides TAU, getUnitVectorFromAngle2 -->
  <script src="rotation.js"></script>     <!-- your rotate()/applyYawPitchRoll* etc. -->

  <script>
    // ========= Visual demo =========
    const canvas = document.getElementById('cv');
    const ctx = canvas.getContext('2d');
    const $ph   = document.getElementById('ph');
    const $zmax = document.getElementById('zmax');
    const $zrms = document.getElementById('zrms');
    const $xmax = document.getElementById('xmax');
    const $xrms = document.getElementById('xrms');
    const $ymax = document.getElementById('ymax');
    const $yrms = document.getElementById('yrms');
    const $cmax = document.getElementById('cmax');
    const $crms = document.getElementById('crms');
    const $ops  = document.getElementById('ops');
    const $log  = document.getElementById('log');
    const $runRnd = document.getElementById('runRnd');
    const $runEdge = document.getElementById('runEdge');
    const $mode = document.getElementById('mode');

    function resize(){
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    addEventListener('resize', resize); resize();

    let tick = 0;
    const TICKS_PER_REV = 720;
    const STEP_RAD = TAU / TICKS_PER_REV;

    const SIGNS = [
      [-1,-1,-1],[ 1,-1,-1],[ 1, 1,-1],[-1, 1,-1],
      [-1,-1, 1],[ 1,-1, 1],[ 1, 1, 1],[-1, 1, 1]
    ];
    const EDGES = [0,1, 1,2, 2,3, 3,0, 4,5, 5,6, 6,7, 7,4, 0,4, 1,5, 2,6, 3,7];

    const F = 520, D = 6.0;
    function projectToScreen(x, y, z){
      const denom = (z + D);
      const sx = canvas.width * 0.5 + (x * F) / denom;
      const sy = canvas.height * 0.5 - (y * F) / denom;
      return [sx, sy];
    }

    function drawCubeAxisAligned(cx, cy, cz, S, axis, theta, color){
      ctx.strokeStyle = color; ctx.lineWidth = 2;
      const verts2d = new Array(SIGNS.length);
      for (let i = 0; i < SIGNS.length; i++){
        let x = SIGNS[i][0] * S, y = SIGNS[i][1] * S, z = SIGNS[i][2] * S;
        [x, y, z] = applyAxisRotateAxisAngle(x, y, z, axis, theta);
        x += cx; y += cy; z += cz;
        verts2d[i] = projectToScreen(x, y, z);
      }
      ctx.beginPath();
      for (let e = 0; e < EDGES.length; e += 2){
        const a = verts2d[EDGES[e]], b = verts2d[EDGES[e+1]];
        ctx.moveTo(a[0], a[1]); ctx.lineTo(b[0], b[1]);
      }
      ctx.stroke();
    }

    function drawCubeWithPose(cx, cy, cz, S, pose, color){
      ctx.strokeStyle = color; ctx.lineWidth = 2;
      const verts2d = new Array(SIGNS.length);
      for (let i = 0; i < SIGNS.length; i++){
        let x = SIGNS[i][0] * S, y = SIGNS[i][1] * S, z = SIGNS[i][2] * S;
        [x, y, z] = pose.apply(x, y, z);
        x += cx; y += cy; z += cz;
        verts2d[i] = projectToScreen(x, y, z);
      }
      ctx.beginPath();
      for (let e = 0; e < EDGES.length; e += 2){
        const a = verts2d[EDGES[e]], b = verts2d[EDGES[e+1]];
        ctx.moveTo(a[0], a[1]); ctx.lineTo(b[0], b[1]);
      }
      ctx.stroke();
    }

    const S = 0.8, Zpos = 4.0;
    function screenDeltaToWorld(pix){ return pix * (Zpos + D) / F; }

    // ========= Quaternion reference (using your custom trig for half-angles) =========
    function quatFromAxisAngle(axis, theta){
      const { x: c, y: s } = getUnitVectorFromAngle2(theta * 0.5, true);
      return [c, axis[0]*s, axis[1]*s, axis[2]*s]; // [w, x, y, z]
    }
    function quatMul(a, b){
      const aw=a[0], ax=a[1], ay=a[2], az=a[3];
      const bw=b[0], bx=b[1], by=b[2], bz=b[3];
      return [
        aw*bw - ax*bx - ay*by - az*bz,
        aw*bx + ax*bw + ay*bz - az*by,
        aw*by - ax*bz + ay*bw + az*bx,
        aw*bz + ax*by - ay*bx + az*bw
      ];
    }
    function quatRotateVec(q, v){
      // v' = v + 2w(u×v) + 2(u×(u×v))
      const w=q[0], ux=q[1], uy=q[2], uz=q[3];
      const tx = 2 * (uy*v[2] - uz*v[1]);
      const ty = 2 * (uz*v[0] - ux*v[2]);
      const tz = 2 * (ux*v[1] - uy*v[0]);
      return [
        v[0] + w*tx + (uy*tz - uz*ty),
        v[1] + w*ty + (uz*tx - ux*tz),
        v[2] + w*tz + (ux*ty - uy*tx)
      ];
    }
    function quatFromChainZXY(alpha, beta, gamma){
      const qz = quatFromAxisAngle([0,0,1], alpha);
      const qx = quatFromAxisAngle([1,0,0], beta);
      const qy = quatFromAxisAngle([0,1,0], gamma);
      return quatMul(qy, quatMul(qx, qz)); // apply Z, then X, then Y
    }
    function quatFromChainZYZ(z1, y, z2){
      const qz1 = quatFromAxisAngle([0,0,1], z1);
      const qy  = quatFromAxisAngle([0,1,0], y);
      const qz2 = quatFromAxisAngle([0,0,1], z2);
      return quatMul(qz2, quatMul(qy, qz1)); // apply Z, then Y, then Z
    }

    // ========= Visual error metrics (symbolic vs quat) =========
    function maxRmsErrForAxis(axis, theta){
      let maxAbs = 0, ss = 0, n = 0;
      const k = (axis === 'z') ? [0,0,1] : (axis === 'x') ? [1,0,0] : [0,1,0];
      const q = quatFromAxisAngle(k, theta);
      for (let i=0;i<SIGNS.length;i++){
        const p = [SIGNS[i][0]*S, SIGNS[i][1]*S, SIGNS[i][2]*S];
        let rA = applyAxisRotateAxisAngle(p[0], p[1], p[2], axis, theta);
        let rQ = quatRotateVec(q, p);
        const dx = rA[0]-rQ[0], dy = rA[1]-rQ[1], dz = rA[2]-rQ[2];
        const m = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));
        if (m > maxAbs) maxAbs = m;
        ss += dx*dx + dy*dy + dz*dz; n++;
      }
      return {maxAbs, rms: Math.sqrt(ss / (3*n))};
    }

    function maxRmsErrZXY(alpha, beta, gamma){
      const q = quatFromChainZXY(alpha, beta, gamma);
      let maxAbs = 0, ss = 0, n = 0;
      for (let i=0;i<SIGNS.length;i++){
        const p = [SIGNS[i][0]*S, SIGNS[i][1]*S, SIGNS[i][2]*S];
        let a = applyAxisRotateAxisAngle(p[0], p[1], p[2], 'z', alpha);
        a     = applyAxisRotateAxisAngle(a[0], a[1], a[2], 'x', beta);
        a     = applyAxisRotateAxisAngle(a[0], a[1], a[2], 'y', gamma);
        const b = quatRotateVec(q, p);
        const dx = a[0]-b[0], dy = a[1]-b[1], dz = a[2]-b[2];
        const m = Math.max(Math.abs(dx), Math.abs(dy), Math.abs(dz));
        if (m > maxAbs) maxAbs = m;
        ss += dx*dx + dy*dy + dz*dz; n++;
      }
      return {maxAbs, rms: Math.sqrt(ss / (3*n))};
    }

    // ========= Canonicalizer (triangle-wave + parity) for API mode =========
    function canonicalizeZXY_TWP(alpha, beta, gamma){
      const PI = Math.PI, HPI = PI * 0.5;
      const EPS = 1e-15;                 // tiny bias to avoid boundary thrash at ±π/2
      const u = beta + HPI + EPS;
      const m = Math.floor(u / PI);      // how many ±π/2 boundaries crossed
      beta = u - m * PI - HPI;           // reflect β into (-π/2, π/2]
      if (m & 1) { alpha += PI; gamma += PI; } // parity keeps pose identical
      return [alpha, beta, gamma];
    }

    // ========= Visual animation =========
    let animOn = true;
    function fmt(v){
      if (!isFinite(v)) return 'NaN';
      const a = Math.abs(v);
      if (a === 0) return '0';
      if (a >= 1e-3 && a < 1e3) return v.toFixed(12).replace(/0+$/,'').replace(/\.$/,'');
      return v.toExponential(3);
    }

    function frame(){
      if (animOn){
        tick = (tick + 1) % TICKS_PER_REV;
        const phi = tick * STEP_RAD;
        $ph.textContent = tick.toString();

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const spacingXpx = canvas.width / 4;
        const spacingYpx = canvas.height / 4;
        const wdx = screenDeltaToWorld(spacingXpx);
        const wdy = screenDeltaToWorld(spacingYpx);

        const cx1 = -wdx, cx2 = 0, cx3 = wdx;
        const cyMid = 0;

        drawCubeAxisAligned(cx1, cyMid, Zpos, S,     'z', phi, '#00ffff'); // XY plane
        drawCubeAxisAligned(cx2, cyMid, Zpos, S,     'x', phi, '#ff66ff'); // YZ plane
        drawCubeAxisAligned(cx3, cyMid, Zpos, S,     'y', phi, '#ffff66'); // ZX plane

        // Pose: use your rotate() (internal canonicalize as per your lib)
        const cx4 = 0, cy4 = -wdy, S4  = S * 1.25;
        //const pose = rotate(/*yaw*/phi, /*pitch*/phi, /*roll*/phi);
		const pose = makePoseZXY_CS(/*yaw*/phi, /*pitch*/phi, /*roll*/phi, true);

        drawCubeWithPose(cx4, cy4, Zpos, S4, pose, '#ffffff');

        const ez = maxRmsErrForAxis('z', phi);
        const ex = maxRmsErrForAxis('x', phi);
        const ey = maxRmsErrForAxis('y', phi);
        const { yaw: alpha, pitch: beta, roll: gamma } = pose.angles();
        const ec = maxRmsErrZXY(alpha, beta, gamma);

        $zmax.textContent = fmt(ez.maxAbs); $zrms.textContent = fmt(ez.rms);
        $xmax.textContent = fmt(ex.maxAbs); $xrms.textContent = fmt(ex.rms);
        $ymax.textContent = fmt(ey.maxAbs); $yrms.textContent = fmt(ey.rms);
        $cmax.textContent = fmt(ec.maxAbs); $crms.textContent = fmt(ec.rms);
      }
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);

    // ========= Benchmark harness =========
    function logln(s){ $log.textContent += s + "\n"; $log.scrollTop = $log.scrollHeight; }
    function clearlog(){ $log.textContent=""; }

    // LCG PRNG
    let rngState = 123456789>>>0;
    function seedLCG(s){ rngState = (s>>>0) || 1; }
    function rnd01(){ rngState = (1664525 * rngState + 1013904223) >>> 0; return rngState / 4294967296; }
    function rndAngle(){ return (rnd01()*2 - 1) * Math.PI; } // [-π, π]
    function makeSeq(N, seed){ seedLCG(seed); const a=new Float64Array(N); for (let i=0;i<N;i++) a[i]=rndAngle(); return a; }

    // Edge angles
    const EPS = 1e-12;
    const E = [
      0, EPS, -EPS,
      Math.PI, -Math.PI,
      Math.PI - EPS, -Math.PI + EPS,
      0.5*Math.PI, -0.5*Math.PI,
      0.5*Math.PI - EPS, -0.5*Math.PI + EPS,
      0.5*Math.PI + EPS, -0.5*Math.PI - EPS
    ];

    function bench(name, N, fn){
      const t0 = performance.now();
      let csum = 0;
      let maxDev = 0;
      for (let i=0;i<N;i++){
        const r = fn(i);
        const lenSq = r[0]*r[0] + r[1]*r[1] + r[2]*r[2];
        const dev = Math.abs(1 - lenSq);
        if (dev > maxDev) maxDev = dev;
        csum += r[0] + r[1]*0.5 + r[2]*0.25;
      }
      const t1 = performance.now();
      return { name, ms: (t1 - t0), checksum: csum, maxDev };
    }

    // Shared angle prep (API vs Kernel)
    function prepAngles(a,b,c, mode){
      if (mode === 'api') return canonicalizeZXY_TWP(a,b,c);
      return [a,b,c];
    }

    // Single-axis (symbolic / quat)
    function makeBenchZsymbolic(vec, N, seq){ return bench("Symbolic Z-only", N, (i)=> rotateAxisAngle(vec, [0,0,1], seq[i])); }
    function makeBenchYsymbolic(vec, N, seq){ return bench("Symbolic Y-only", N, (i)=> rotateAxisAngle(vec, [0,1,0], seq[i])); }
    function makeBenchZquat(vec, N, seq){ return bench("Quaternion Z-only", N, (i)=> quatRotateVec(quatFromAxisAngle([0,0,1], seq[i]), vec)); }
    function makeBenchYquat(vec, N, seq){ return bench("Quaternion Y-only", N, (i)=> quatRotateVec(quatFromAxisAngle([0,1,0], seq[i]), vec)); }

    // Z–X–Y chain
    function makeBenchZXYsymbolic(vec, N, yawSeq, pitSeq, rolSeq, mode){
      return bench("Symbolic ZXY", N, (i)=>{
        const [a,b,c] = prepAngles(yawSeq[i], pitSeq[i], rolSeq[i], mode);
        let p = rotateAxisAngle(vec, [0,0,1], a);
        p     = rotateAxisAngle(p,   [1,0,0], b);
        p     = rotateAxisAngle(p,   [0,1,0], c);
        return p;
      });
    }
    function makeBenchZXYquat(vec, N, yawSeq, pitSeq, rolSeq, mode){
      return bench("Quaternion ZXY", N, (i)=>{
        const [a,b,c] = prepAngles(yawSeq[i], pitSeq[i], rolSeq[i], mode);
        return quatRotateVec(quatFromChainZXY(a,b,c), vec);
      });
    }

    // Z–Y–Z chain
    function makeBenchZYZsymbolic(vec, N, z1Seq, ySeq, z2Seq, mode){
      return bench("Symbolic ZYZ", N, (i)=>{
        const [z1,y,z2] = prepAngles(z1Seq[i], ySeq[i], z2Seq[i], mode);
        let p = rotateAxisAngle(vec, [0,0,1], z1);
        p     = rotateAxisAngle(p,   [0,1,0], y);
        p     = rotateAxisAngle(p,   [0,0,1], z2);
        return p;
      });
    }
    function makeBenchZYZquat(vec, N, z1Seq, ySeq, z2Seq, mode){
      return bench("Quaternion ZYZ", N, (i)=>{
        const [z1,y,z2] = prepAngles(z1Seq[i], ySeq[i], z2Seq[i], mode);
        return quatRotateVec(quatFromChainZYZ(z1,y,z2), vec);
      });
    }

    async function runBenches(kind){
      const N = Math.max(1000, (parseInt($ops.value, 10) || 10000000));
      const mode = $mode.value; // 'api' or 'kernel'
      clearlog();
      logln(`=== BENCH START (${kind}, mode=${mode}), N=${N.toLocaleString()} ===`);
      animOn = false; // pause animation

      // warm-up (JIT)
      (function warm(){
        bench("warm", 20000, i => rotateAxisAngle([0.3,0.2,0.1],[0,0,1], (i&1023)*1e-6));
      })();

      const baseVec = [0.37, -0.81, 0.56];

      let results = [];

      if (kind === 'random'){
        // Precompute sequences so both paths read identical angles
        const Z_seq   = makeSeq(N, 0xA11CE);
        const Y_seq   = makeSeq(N, 0xB00B5);
        const Yaw_seq = makeSeq(N, 0xC0FFEE);
        const Pit_seq = makeSeq(N, 0xC0FFEF);
        const Rol_seq = makeSeq(N, 0xC0FFF0);
        const Z1_seq  = makeSeq(N, 0xD15EA5E);
        const YY_seq  = makeSeq(N, 0xD15EA5F);
        const Z2_seq  = makeSeq(N, 0xD15EA60);

        results.push( makeBenchZsymbolic(baseVec, N, Z_seq) );
        results.push( makeBenchZquat    (baseVec, N, Z_seq) );

        results.push( makeBenchYsymbolic(baseVec, N, Y_seq) );
        results.push( makeBenchYquat    (baseVec, N, Y_seq) );

        results.push( makeBenchZXYsymbolic(baseVec, N, Yaw_seq, Pit_seq, Rol_seq, mode) );
        results.push( makeBenchZXYquat    (baseVec, N, Yaw_seq, Pit_seq, Rol_seq, mode) );

        results.push( makeBenchZYZsymbolic(baseVec, N, Z1_seq, YY_seq, Z2_seq, mode) );
        results.push( makeBenchZYZquat    (baseVec, N, Z1_seq, YY_seq, Z2_seq, mode) );
      } else {
        // Edge cases: reuse deterministic list E
        const genE = (i)=> E[i % E.length];

        results.push( bench("Symbolic Z-only", N, (i)=> rotateAxisAngle(baseVec, [0,0,1], genE(i))) );
        results.push( bench("Quaternion Z-only", N, (i)=> quatRotateVec(quatFromAxisAngle([0,0,1], genE(i)), baseVec)) );

        results.push( bench("Symbolic Y-only", N, (i)=> rotateAxisAngle(baseVec, [0,1,0], genE(i))) );
        results.push( bench("Quaternion Y-only", N, (i)=> quatRotateVec(quatFromAxisAngle([0,1,0], genE(i)), baseVec)) );

        results.push( bench("Symbolic ZXY", N, (i)=>{
          const [a,b,c] = prepAngles(genE(i), genE(i), genE(i), mode);
          let p = rotateAxisAngle(baseVec, [0,0,1], a);
          p     = rotateAxisAngle(p,       [1,0,0], b);
          p     = rotateAxisAngle(p,       [0,1,0], c);
          return p;
        }) );
        results.push( bench("Quaternion ZXY", N, (i)=>{
          const [a,b,c] = prepAngles(genE(i), genE(i), genE(i), mode);
          return quatRotateVec(quatFromChainZXY(a,b,c), baseVec);
        }) );

        results.push( bench("Symbolic ZYZ", N, (i)=>{
          const [z1,y,z2] = prepAngles(genE(i), genE(i), genE(i), mode);
          let p = rotateAxisAngle(baseVec, [0,0,1], z1);
          p     = rotateAxisAngle(p,       [0,1,0], y);
          p     = rotateAxisAngle(p,       [0,0,1], z2);
          return p;
        }) );
        results.push( bench("Quaternion ZYZ", N, (i)=>{
          const [z1,y,z2] = prepAngles(genE(i), genE(i), genE(i), mode);
          return quatRotateVec(quatFromChainZYZ(z1,y,z2), baseVec);
        }) );
      }

      const pad = (s, n)=> (s + ' '.repeat(n)).slice(0,n);
      for (const r of results){
        const nsPerOp = (r.ms * 1e6 / N);
        logln(`${pad(r.name,18)} time=${r.ms.toFixed(2)} ms  ns/op=${nsPerOp.toFixed(2)}  checksum=${r.checksum}  maxDev=${r.maxDev.toExponential(3)}`);
        await new Promise(res=>setTimeout(res,0));
      }
      logln(`=== BENCH END ===`);
      animOn = true;
    }

    $runRnd.onclick  = ()=> runBenches('random');
    $runEdge.onclick = ()=> runBenches('edge');
  </script>
</body>
</html>
